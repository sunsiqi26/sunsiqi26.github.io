[{"categories":["Paper"],"content":"物联网相关攻击阶段的检测和识别","date":"2022-08-24","objectID":"/public/pr-adept/","tags":["attack stage","IoT"],"title":"Paper Reading-ADEPT","uri":"/public/pr-adept/"},{"categories":["Paper"],"content":"物联网相关攻击阶段的检测和识别 原文标题：ADEPT: Detection and identification of correlated attack stages in IoT networks 原文作者：Sudheera K L K, Divakaran D M, Singh R P, et al. 原文链接：https://ieeexplore.ieee.org/abstract/document/9343343 发表期刊：IEEE INTERNET OF THINGS JOURNAL'21 ","date":"2022-08-24","objectID":"/public/pr-adept/:0:0","tags":["attack stage","IoT"],"title":"Paper Reading-ADEPT","uri":"/public/pr-adept/"},{"categories":["Paper"],"content":"简介 针对物联网相关攻击阶段识别面临的时间分散和空间分散两大挑战，论文提出了一个分布式框架ADEPT，可以跨时间和空间关联可疑活动并将其分类为可能的攻击阶段。 ","date":"2022-08-24","objectID":"/public/pr-adept/:1:0","tags":["attack stage","IoT"],"title":"Paper Reading-ADEPT","uri":"/public/pr-adept/"},{"categories":["Paper"],"content":"方法 ADEPT框架分为三阶段 第一阶段：通过物联网网关设备检测各种异常。 离线操作：建立哈希表存储与网关连接的物联网设备的配置表以检测设备变化，由于设备的正常行为可能随时间推移而改变，例如固件更新，因此定期(几天为周期)更新哈希表。 在线操作：分析设备流量以检测异常(连接异常和行为异常)，生成流量异常的元信息(警报)，网关向上只发送警报。减少了带宽消耗和私人信息泄露风险。 第二阶段：处理和关联不同网关产生的警报。 基于频繁项集挖掘(FIM)提取攻击阶段相对应的模式同时过滤由于固件更新等产生的虚假警报。 提出了一种基于滑动窗口的挖掘算法，基于当前时间窗口中发现的新模式来发现先前时间窗口中遗漏的模式，使得ADEPT能考虑到时间相关性。 第三阶段：使用警报级别和模式级别的特征训练基于机器学习的多分类模型。 警报级别特征：源IP和目的IP、网络流向、协议。 模式级别特征：IP和端口流量方向、向内和向外的平均数据包大小、FIM阶段的支持度、源节点与目标节点的数量比、每个IP的交互端口数量、模式识别中的特殊属性、实体。 攻击阶段类别： ","date":"2022-08-24","objectID":"/public/pr-adept/:2:0","tags":["attack stage","IoT"],"title":"Paper Reading-ADEPT","uri":"/public/pr-adept/"},{"categories":["Paper"],"content":"实验 作者模拟了一个物联网网络和Mirai攻击环境，实验装置：一台安全管理器、65台IoT设备、一台靶机、两个外部僵尸网络、一台C\u0026C服务器、一台装载机、一组虚拟机(触发警报)。 实验一：对比了对警报应用子网划分和不应用子网划分两种IP地址表示方法对效果的影响，应用子网划分方式的F1值更高且能识别出更多的模式。 实验二：测试空间相关性在攻击阶段检测中的影响，即是否通过安全管理器装置关联不同网关的警告，实验表明安全管理器效果更好。 实验三：时间相关性影响，基于滑动窗口方法的效果最好。 攻击阶段识别 进一步，作者在IoT23-43数据集和混合数据集上进行实验，均取得了较好的实验结果。","date":"2022-08-24","objectID":"/public/pr-adept/:3:0","tags":["attack stage","IoT"],"title":"Paper Reading-ADEPT","uri":"/public/pr-adept/"},{"categories":["Paper"],"content":"开源软件供应链攻击分类","date":"2022-07-31","objectID":"/public/pr-taxonomy/","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"开源软件供应链攻击分类 原文标题：Taxonomy of Attacks on Open-Source Software Supply Chain 原文作者：Piergiorgio Ladisa, Henrik Plate, Matias Martinez, Olivier Barais 原文链接：https://arxiv.org/pdf/2204.04008.pdf 原文来源：S\u0026P'22 ","date":"2022-07-31","objectID":"/public/pr-taxonomy/:0:0","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"简介 现有研究缺乏对攻击者如何将恶意代码注入OSS项目的全面、可理解、通用性的描述。论文关注开源软件供应链攻击，提出了一种针对开源供应链攻击的通用分类法，独立于特定的编程语言或生态系统，涵盖了从代码贡献到包分发的所有阶段，与真实事件关联并映射到安全缓解措施。邀请了17名领域专家和134名开发者对分类和相应安全措施的有效性进行定性评估。 ","date":"2022-07-31","objectID":"/public/pr-taxonomy/:1:0","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"方法 首先，作者回顾了相关论文和灰色文献，以收集OSS供应链上的攻击载体的广泛列表。其次，将文献中描述的向量从特定的编程语言或生态系统中提取出来，进行威胁建模，并确定减轻这些向量的安全措施。最后，为了验证所提出的分类和安全措施列表，作者设计并运行了两个用户调查：OSS供应链安全领域的专家调查和软件开发人员调查。 文献数据：搜索四个数字图书馆：Google scholar（980）、arXiv（6）、IEE Explore（25）和ACM数字图书馆（160）。人工提取有关常见威胁、攻击载体和相关保障措施的信息。灰色文献主要来自开源数据集和安全博客。 攻击场景的分析与建模：基于文献[1]的攻击树，确定了额外的攻击向量。 构建标准：对现有生态系统（一级节点）的干扰程度、软件供应链的各个阶段（即源、构建、分发），以及每个阶段所涉及的系统和利益相关者。 模型如图1所示，一级节点包括开始创建恶意软件包、创建名称混淆的恶意软件包、转化合法软件包。转化合法软件包节点下包括三个二级节点：恶意代码注入、包构建时注入、分发恶意版本软件包。 \r 安全措施的识别和分类：根据控制类型、利益相关者参与和减轻攻击向量对每个安全措施进行分类。控制类型分类遵循众所周知的指令、预防、检测、纠正和恢复控制。利益相关者包括维护者、系统管理员、用户。最后，每个安全措施被分配给可能的深度最小的树节点。(附录表II) 针对项目维护人员和管理人员：包括八项保障措施，例如，安全身份验证建议服务提供商提供多因素身份验证(MFA)或强制执行强密码策略 针对项目维护人员：包括七项对策，例如，维护者应该进行仔细的合并请求审查或为敏感的项目分支启用分支保护规则，以避免恶意的代码贡献。 针对管理者和消费者：包括五种对策，例如，包存储库管理员和消费者都可以选择直接从源代码中构建包，而不是接受预先构建的工件。 针对消费者：包括下游用户可能采用的九种应对措施。OSS包的用户可以通过隔离代码和/或沙箱来减少使用时恶意代码执行的影响。 用户调查： 收集调查参与者背景信息尤其是技能，tree-testing验证树节点关系，用Likert scale对结构、节点名称、覆盖率和有效性进行评分。 开发人员：参与者被问及他们是否知道此类攻击，以及他们或他们的组织是否使用了任何减轻罪行的安全措施。 采用滚雪球抽样由最初的参与者分析邀请 调查结果文件分布式存储在云端 ","date":"2022-07-31","objectID":"/public/pr-taxonomy/:2:0","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"评估 论文对提出的攻击分类和安全措施进行了全面评估 A. 攻击分类评估 专家评估：树形测试攻击树结构合理性(75%的节点结构合理)、Likert评分(82%的专家打分在4-5分)、72%的专家同意攻击树的完整性。 开发者评估：开发者是否了解主要攻击向量(64%-90%不等)、Likert评分(77%认为分类法可理解，87%认为分类法有帮助意义) B. 安全措施评估 从U/C比(Utility-to-Cost)角度打分，结果如表1所示 \r","date":"2022-07-31","objectID":"/public/pr-taxonomy/:3:0","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"讨论 不同生态系统之间存在区别，一些攻击技术确实独立于特定的生态系统/语言，但一些攻击或检测方法是特定的，例如：滥用依赖解析攻击、执行或触发恶意代码、代码混淆和恶意软件检测。 ","date":"2022-07-31","objectID":"/public/pr-taxonomy/:4:0","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"总结 论文通过对现有工作进行总结和抽象，将开源软件供应链安全的知识系统化，并做了大量工作评估分类的有效性。提出的针对开源供应链攻击的分类法和安全缓解措施，有助于评估开源项目的安全风险、制定安全策略。 [1]. M. Ohm, H. Plate, A. Sykosch, and M. Meier, “Backstabber’s knife collection: A review of open source software supply chain attacks,” 2020. ","date":"2022-07-31","objectID":"/public/pr-taxonomy/:5:0","tags":["supply chain","attack ontology"],"title":"Paper Reading-Supply Chain","uri":"/public/pr-taxonomy/"},{"categories":["Paper"],"content":"针对不安全项目依赖的大规模实证研究","date":"2022-07-25","objectID":"/public/pr-pdgraph/","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Paper"],"content":"针对不安全项目依赖的大规模实证研究 原文标题：PDGraph: A Large-Scale Empirical Study on Project Dependency of Security Vulnerabilities 原文作者：Qiang Li; Jinke Song; Dawei Tan; Haining Wang; Jiqiang Liu 原文链接：https://ieeexplore.ieee.org/document/9505106 原文来源：DSN'21 ","date":"2022-07-25","objectID":"/public/pr-pdgraph/:0:0","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Paper"],"content":"简介 代码重用可能带来潜在的安全问题，不同的软件项目可能同时由相互依赖的重用组件引入漏洞。论文通过构建一个新的项目依赖关系图PDGraph，对项目依赖关系与安全漏洞进行了首次大规模实证研究。 ","date":"2022-07-25","objectID":"/public/pr-pdgraph/:1:0","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Paper"],"content":"挑战 项目的构建文件只提供分离的依赖关系，需要遍历项目重用库中的构建文件才能获得完整的依赖关系。 解决：将依赖关系分为 Full/Whole Dataset (Maven) 和 Partial Dataset (GitHub) 两类 如何整合不同来源数据集(NVD、Maven、GitHub)的信息来判断项目是否存在漏洞。 解决：对漏洞信息和项目依赖间的一致性进行了量化 ","date":"2022-07-25","objectID":"/public/pr-pdgraph/:2:0","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Paper"],"content":"方法 A.数据收集 依赖关系 Maven：解析pom.xml建立有向边 GitHub：针对Java、Ruby、Python、.NET、JavaScript五种语言不同的依赖声明文件，借助API爬取依赖声明文件。将GitHub数据集分为三类：A类(涉及漏洞的项目)、B类(直接使用A类项目库的项目)、C类(间接使用A类项目库的项目) 关联漏洞 相似度匹配：统计文本特征提取相关词，使用Levenshtein距离计算Maven、GitHub项目描述和CPE间相似度。 URL：比较NVD漏洞报告中的url与Maven、GitHub项目的url。 第三方数据：Advisory database、CVE、 manually-curated dataset。 B. 构建项目依赖图 定义四项指标评估依赖风险：依赖项目数量、依赖该项目的项目数量、依赖路径长度、循环依赖。 生成依赖图，通过SCC简化PDGraph，利用MFAS保证局部图的层次结构，然后对于每个SCC生成有向无环图DAG. 检测不安全的边：正则匹配依赖关系边缘中的需求版本和漏洞版本。 ","date":"2022-07-25","objectID":"/public/pr-pdgraph/:3:0","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Paper"],"content":"实验 数据集： 不安全边发现： ","date":"2022-07-25","objectID":"/public/pr-pdgraph/:4:0","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Paper"],"content":"总结 论文构建了第一个针对安全漏洞的项目依赖图，发现了大量由于项目依赖而引入的不安全边，可以为代码审计、防御代码重用攻击等提供帮助。但仍存在一些不足： PDGraph基于项目构建文件创建，可能存在人为错误； PDGraph目前不支持构建C和C++项目依赖； 并非所有漏洞都是可传递的，现有的不安全边可能存在误报； 定义的四项依赖风险评估指标有待完善。 ","date":"2022-07-25","objectID":"/public/pr-pdgraph/:5:0","tags":["KG","project dependency"],"title":"Paper Reading-NPM","uri":"/public/pr-pdgraph/"},{"categories":["Note"],"content":"V8 Bytecode学习记录","date":"2022-07-11","objectID":"/public/note-bytecode/","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"V8 Bytecode学习记录 ","date":"2022-07-11","objectID":"/public/note-bytecode/:0:0","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"V8 bytecode ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:0","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"环境 win10 + vs2017 下载链接：https://my.visualstudio.com/Downloads?q=visual%20studio%202017\u0026wt.mc_id=o~msft~vscom~older-downloads 企业版：NJVYC-BMHX2-G77MM-4XJMR-6Q8QF 专业版：KBJFW-NXHK6-W4WJM-CRMQB-G3CDH git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git fetch v8 git checkout -b 7.3 -t branch-heads/7.3 set DEPOT_TOOLS_WIN_TOOLCHAIN=0 set GYP_MSVS_OVERRIDE_PATH=F:\\Microsoft Visual Studio\\2017 set WINDOWSSDKDIR=D:\\Windows Kits\\10 gclient sync python3 tools\\dev\\v8gen.py x64.debug ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:1","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"指令 StackCheck：固定出现，检查stack有没有overflow Ld*属于加载到累加器的指令集 Star寄存器操作指令 src/interpreter/interpreter-generator.cc ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:2","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"功能 变量赋值，寄存器变化，抛出错误 判断式，对于 if (true) 这种case，V8 Ignition 会做优化。在程式码中同一个字串是可以被重复利用的，都是指向同一个constant pool 的元素 loop， 函数 ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:3","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"生成 通过遍历AST树结构生成，具体实现是switch case配合预设的宏定义模板。AST树的所有节点都继承自AstNode类，AstNode的NodeType将父类转成具体的子类，之后才能进行数据读取，生成字节码。V8中AST到字节码的翻译过程，与编译LLVM中AST到三地址码的翻译相似。 AstNode –\u003e Assignment void BytecodeGenerator::VisitAssignment(Assignment* expr) { AssignmentLhsData lhs_data = PrepareAssignmentLhs(expr-\u003etarget()); VisitForAccumulatorValue(expr-\u003evalue()); builder()-\u003eSetExpressionPosition(expr); BuildAssignment(lhs_data, expr-\u003eop(), expr-\u003elookup_hoisting_mode()); } Bytecode入口BytecodeGenerator::GenerateBytecodeBody() –\u003e 进入VisitStatements(literal-\u003ebody())生成字节码 https://www.zhihu.com/people/v8blink/posts?page=4 编译涉及到的概念包括：词法分析，用来生成token字；语法分析(parse)，最后生成抽象语法树（AST）。 ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:4","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"bytecode序列能否应用于为静态分析兜底分析代码意图 操作码n-gram？当前操作码出现的概率只与前n个有关 Android字节码转化的目的是减少代码本身的语义信息、增加其安全性并减少混淆带来的性能消耗。 由于JavaScript是动态类型、面向原型的语言，对象和变量的美型可能随时发生变化，所以只有在运行阶段才可以真正确定变量和对象的类型，因此在编译阶段对热点函数代码进行优化时需要进行类型特化(ype specifitatin,即假定热点函数中变量是某种类型，但这是不可靠的，所以在运行机器码之前需要进行检查，即deoptimizaton check,确保变量的类型和JT编译时假定类型一样，如果deoptirmzation check失败，表示热点函数中数据类型发生了变化，需要进行脱优化(deoptimization)处理，即转到相应的字节码处重新执行。 是第一个应用字节码来表示漏洞特征，并采用基于图的静态分析方法来提取字节码片 https://link.springer.com/chapter/10.1007/978-3-030-41579-2_12 基于恶意软件行为序列(API调用序列)的动态分析 base64、16进制类似编码，constant pool有明文 const { exec } = require(\"child_process\") exec('calc.exe') eval(Buffer.from('Y29uc3QgeyBleGVjIH0gPSByZXF1aXJlKCJjaGlsZF9wcm9jZXNzIikKZXhlYygnY2FsYy5leGUnKQ==', 'base64').toString()) [generated bytecode for function: (0x01a165689651 \u003cSharedFunctionInfo\u003e)] Parameter count 1 Register count 4 Frame size 32 0 E\u003e 000001A16568975E @ 0 : 85 00 01 CreateEvalContext [0], [1] 000001A165689761 @ 3 : 16 fa PushContext r1 000001A165689763 @ 5 : 0f LdaTheHole 000001A165689764 @ 6 : 1d 02 StaCurrentContextSlot [2] 17 S\u003e 000001A165689766 @ 8 : 18 fa 06 00 LdaContextSlot r1, [6], [0] 000001A16568976A @ 12 : 26 f9 Star r2 000001A16568976C @ 14 : 12 01 LdaConstant [1] 000001A16568976E @ 16 : 26 f8 Star r3 17 E\u003e 000001A165689770 @ 18 : 5d f9 f8 00 CallUndefinedReceiver1 r2, r3, [0] 000001A165689774 @ 22 : 26 f9 Star r2 8 S\u003e 000001A165689776 @ 24 : 28 f9 02 02 LdaNamedProperty r2, [2], [2] 000001A16568977A @ 28 : 1d 02 StaCurrentContextSlot [2] 42 S\u003e 000001A16568977C @ 30 : 1b 02 LdaImmutableCurrentContextSlot [2] 000001A16568977E @ 32 : 26 f9 Star r2 000001A165689780 @ 34 : 12 03 LdaConstant [3] 000001A165689782 @ 36 : 26 f8 Star r3 42 E\u003e 000001A165689784 @ 38 : 5d f9 f8 04 CallUndefinedReceiver1 r2, r3, [4] 000001A165689788 @ 42 : 26 fb Star r0 58 S\u003e 000001A16568978A @ 44 : aa Return Constant pool (size = 4) 000001A1656896F9: [FixedArray] in OldSpace - map: 0x01a859fc0729 \u003cMap\u003e - length: 4 0: 0x01a165689689 \u003cScopeInfo EVAL_SCOPE [10]\u003e 1: 0x006767481669 \u003cString[#13]: child_process\u003e 2: 0x01a859fc3521 \u003cString[#4]: exec\u003e 3: 0x01a165689621 \u003cString[#8]: calc.exe\u003e Handler Table (size = 0) Source Position Table (size = 17) 0x01a165689791 \u003cByteArray[17]\u003e 逻辑结构混淆：hoisting机制自动会解决一些 标识符混淆 不同函数声明的字节码可能是相同的–\u003e字节码相似性 查看隐藏类：/d8 –allow-natives-syntax ./test.js ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:5","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"字节码逻辑梳理 ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:6","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Note"],"content":"检测方法 恶意npm包字节码 处理：filter、切片？ package.json中的命令 hoisting机制好像会把一些变量、函数等声明提前，字节码的顺序可能更合逻辑 turbofan IR结构 vs v8 ignition ","date":"2022-07-11","objectID":"/public/note-bytecode/:1:7","tags":["V8","bytecode"],"title":"Note-Bytecode","uri":"/public/note-bytecode/"},{"categories":["Paper"],"content":"开源软件项目安全与信任的定性研究","date":"2022-07-03","objectID":"/public/pr-oss/","tags":["oss","security"],"title":"Paper Reading-OSS","uri":"/public/pr-oss/"},{"categories":["Paper"],"content":"开源软件项目安全与信任的定性研究 *原文标题：Committed to Trust: A Qualitative Study on Security \u0026 Trust in Open Source Software Projects 原文作者：Wermke D, Wöhler N, Klemmer J H, et al. 原文链接：https://ieeexplore.ieee.org/document/9833686 发表期刊：S\u0026P'22 ","date":"2022-07-03","objectID":"/public/pr-oss/:0:0","tags":["oss","security"],"title":"Paper Reading-OSS","uri":"/public/pr-oss/"},{"categories":["Paper"],"content":"前期工作 You get where you’re looking for: The impact of information sources on code security - S\u0026P 2016 Security Developer Studies with {GitHub} Users: Exploring a Convenience Sample - SOUPS 2017 ","date":"2022-07-03","objectID":"/public/pr-oss/:0:1","tags":["oss","security"],"title":"Paper Reading-OSS","uri":"/public/pr-oss/"},{"categories":["Paper"],"content":"简介 论文通过调查以下3个问题研究OSS中的安全措施和信任过程，讨论了其对开源软件生态系统的影响，以及研究社区如何以信任和安全考虑更好地支持开源项目。 RQ1：开源项目再安全和信任背景下是如何互动和决策的 RQ2：开源项目是否提供了哪些指导和安全策略？ RQ3：开源项目如何应对信任问题 ","date":"2022-07-03","objectID":"/public/pr-oss/:0:2","tags":["oss","security"],"title":"Paper Reading-OSS","uri":"/public/pr-oss/"},{"categories":["Paper"],"content":"访谈及发现 访谈人员：基于先前工作的数据集，筛选其中活跃用户，将受欢迎程度和活动指标合并排名，最终选出27名访谈用户。 安全挑战：许多参与者熟悉可疑或低质量的提交项目以及依赖项引入的潜在漏洞，只有少量项目遇到直接的安全问题。 指导和安全政策：参与者对（书面的）指导的帮助性有不同的意见。对于安全策略，较大的项目提到了专门的安全团队，而较小的项目提到了安全问题联系通道。 项目构建：参与者充分利用了现代的构建系统，只有少数项目显式地使用已签名的提交。 发布和更新：参与者大多基于直接的社区输入和反馈来发布项目的发布和更新。 角色和责任：大多数项目都没有配备专门用于该项目安全的团队，有些项目要么依赖于组织的资源，要么利用其他团队的成员。 信任：大多数参与者在他们的项目中从未经历过信任问题，也没有建立具体的信任策略。 问题和改进：建议的改进大致分类为：需要更多的人员贡献（15），需要更多钱（9），或需要基础设施（9）。 ","date":"2022-07-03","objectID":"/public/pr-oss/:0:3","tags":["oss","security"],"title":"Paper Reading-OSS","uri":"/public/pr-oss/"},{"categories":["Paper"],"content":"总结 参与者的项目在部署的安全措施和信任过程及其潜在动机方面都具有高度多样化。随着项目范围和贡献者的增长，它们对安全性和信任流程的需求也在增长。作者主张不要将开源开发人员单独视为数据源，并审查流程黑盒，而是将它们视为为作为一个整体的OSS和软件生态系统带来安全性和信任的宝贵合作伙伴。总的来说，我们主张以更好地考虑其个人优势和局限性的方式来支持开源项目，特别是在贡献者数量较低和资源访问量有限的较小项目中。 ","date":"2022-07-03","objectID":"/public/pr-oss/:0:4","tags":["oss","security"],"title":"Paper Reading-OSS","uri":"/public/pr-oss/"},{"categories":["Paper"],"content":"NPM生态中的弃用机制研究","date":"2022-06-14","objectID":"/public/pr-npm/","tags":["npm","deprecation"],"title":"Paper Reading-NPM","uri":"/public/pr-npm/"},{"categories":["Paper"],"content":"NPM生态中的弃用机制研究 *原文标题：Deprecation of Packages and Releases in Software Ecosystems: A Case Study on NPM 原文作者：Cogo F R, Oliva G A, Hassan A E. 原文链接：https://ieeexplore.ieee.org/abstract/document/9351569/ 发表期刊：TSE'22 ","date":"2022-06-14","objectID":"/public/pr-npm/:0:0","tags":["npm","deprecation"],"title":"Paper Reading-NPM","uri":"/public/pr-npm/"},{"categories":["Paper"],"content":"简介 当客户端决定继续使用已弃用的版本时可能会引入风险，但先前的文献并未研究软件生态系统中弃用机制的基本原理。论文研究了npm生态系统中的弃用情况，分析了弃用的原因、对用户的影响及应对方案。 ","date":"2022-06-14","objectID":"/public/pr-npm/:1:0","tags":["npm","deprecation"],"title":"Paper Reading-NPM","uri":"/public/pr-npm/"},{"categories":["Paper"],"content":"数据收集 首先，从package.json中收集npm包元数据(版本号、时间戳、依赖项、弃用信息)，收集了截止2019年5月的全部包。然后，对每个包的相邻包版本进行排序，确定相邻版本号变化原因。最后，分析包依赖关系。 ","date":"2022-06-14","objectID":"/public/pr-npm/:2:0","tags":["npm","deprecation"],"title":"Paper Reading-NPM","uri":"/public/pr-npm/"},{"categories":["Paper"],"content":"发现 RQ1: 发布弃用的频率？ 3.7%的npm包至少有一个弃用的版本，其中66%的包被完全弃用（所有版本都标记为弃用），在部分弃用（一些版本标记为弃用）的包中69%有不止一个弃用版本。 31%的部分弃用包没有替换版本，其中65%的此类弃用包维护被放弃或被取代。 退出是包弃用的最常见的原因（49%），漏洞是版本弃用的最常见的原因（63%）。近三分之二的弃用消息报告包或版本的弃用的原因。总结如下：退出(例如，包的开发不再在npm中维护)、超越（例如，不弃用的版本被更新的、改进的版本取代）、缺陷（例如，发现某个功能有问题）、测试（例如，包仅为测试目的而发布）和不兼容。 RQ2: 弃用的版本在客户端采用的情况如何 直接采用弃用版本(package.json中指定的依赖) 27%的客户端包直接采用至少一个已弃用的版本 小部分弃用版本被客户端包大量采用，前40个流行的弃用版本占所有弃用版本采用的一半以上 所有流行的弃用版本都有声明替代包或迁移版本，简化了从此类弃用版本的迁移 过渡性地采用不赞成使用的版本 54%的所有客户端软件包过渡采用至少一个已弃用的版本 90%的过渡采用最深的依赖深度不大于6 每四个直接采用中会导致至少一个(中位数)传递采用已弃用的版本 ","date":"2022-06-14","objectID":"/public/pr-npm/:3:0","tags":["npm","deprecation"],"title":"Paper Reading-NPM","uri":"/public/pr-npm/"},{"categories":["Paper"],"content":"讨论 完善弃用机制 鼓励开发者提供更有意义的弃用消息：告知弃用的原因、声明替换版本、提供指南文档 以交互方式提供弃用的上下文信息，有助于用户包管理 定期警告客户端采用弃用版本 提供内置功能，用于评估已弃用的提供程序版本的传递采用 当较旧的非弃用版本可用时，弃用机制应防止隐式采用弃用版本 弃用版本的影响 版本弃用在被部分开发者滥用 客户端包应考虑功能、漏洞、迁移工作量等因素来决定选择补丁降级还是更新 ","date":"2022-06-14","objectID":"/public/pr-npm/:4:0","tags":["npm","deprecation"],"title":"Paper Reading-NPM","uri":"/public/pr-npm/"},{"categories":["Note"],"content":"供应链安全学习记录","date":"2022-06-03","objectID":"/public/note-supplychain/","tags":["security","supply chain"],"title":"Note-Supply Chain Security","uri":"/public/note-supplychain/"},{"categories":["Note"],"content":"供应链安全学习记录 ","date":"2022-06-03","objectID":"/public/note-supplychain/:0:0","tags":["security","supply chain"],"title":"Note-Supply Chain Security","uri":"/public/note-supplychain/"},{"categories":["Note"],"content":"文献梳理 \r","date":"2022-06-03","objectID":"/public/note-supplychain/:1:0","tags":["security","supply chain"],"title":"Note-Supply Chain Security","uri":"/public/note-supplychain/"},{"categories":["Note"],"content":"笔记导图 ","date":"2022-06-03","objectID":"/public/note-supplychain/:2:0","tags":["security","supply chain"],"title":"Note-Supply Chain Security","uri":"/public/note-supplychain/"},{"categories":["Paper"],"content":"SP'22相关论文记录","date":"2022-06-01","objectID":"/public/pl-sp22/","tags":["paper list"],"title":"SP'22 paper list","uri":"/public/pl-sp22/"},{"categories":["Paper"],"content":"SP'22相关论文记录 ","date":"2022-06-01","objectID":"/public/pl-sp22/:0:0","tags":["paper list"],"title":"SP'22 paper list","uri":"/public/pl-sp22/"},{"categories":["Paper"],"content":"TROLLMAGNIFIER: Detecting State-Sponsored Troll Accounts on Reddit Troll Accounts在行为上与普通用户不同，点击Troll Accounts发布的内容可能导致恶意行为，通过选取特征集和随机森林等机器学习方法检测。 ","date":"2022-06-01","objectID":"/public/pl-sp22/:1:0","tags":["paper list"],"title":"SP'22 paper list","uri":"/public/pl-sp22/"},{"categories":["Paper"],"content":"将部分JavaScript恶意代码转换为WebAssembly以逃避检测","date":"2022-05-24","objectID":"/public/pr-js/","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"将部分JavaScript恶意代码转换为WebAssembly以逃避检测 原文标题：Wobfuscator: Obfuscating JavaScript Malware via Opportunistic Translation to WebAssembly 原文作者：Romano A, Lehmann D, Pradel M, et al. 发表会议：Proceedings of the 2022 IEEE Symposium on Security and Privacy (S\u0026P 2022) 原文链接：https://www.software-lab.org/publications/sp2022.pdf ","date":"2022-05-24","objectID":"/public/pr-js/:0:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"简介 目前的检测器以JavaScript为唯一的目标语言，然而忽略了WebAssembly可能带来的攻击。论文提出了第一个通过将计算的部分移动到WebAssembly中来逃避静态JavaScript恶意软件检测的技术。技术的核心是将JavaScript中实现恶意行为的片段翻译为WebAssembly。通过实验评估，该方法可以有效逃逸最先进的基于学习的静态恶意软件检测。 ","date":"2022-05-24","objectID":"/public/pr-js/:1:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"背景 JavaScript存在问题：JavaScript中的每条指令都要经过几次类型检查和转换，这会影响到它的执行速度。JavaScript不是为CPU密集型和高性能应用程序开发的，在WebAssembly发布前，JavaScript是客户端浏览器的唯一语言。 WebAssembly（WASM）：可以将任何高级语言编写的代码转换为浏览器可理解的机器码的技术，帮助简化编译过程，为用C和C++等语言编写的计算密集型库提供了一个有效的编译目标。 ","date":"2022-05-24","objectID":"/public/pr-js/:2:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"方法 Wobfuscator的整体架构如图1所示，shut为一个JavaScript文件，作者将其解析为AST，接下来，该方法识别潜在的转换片段(i)与检测相关的恶意代码和(ii)可以以保留语义的方式转换为WebAssembly的代码（该方法不是通用转换，只针对满足以上两点要求的代码片段）。最后输出转换后的JavaScript代码和多个生成的WebAssembly模块 \r 转换规则：作者定义了针对JavaScript不同特性的七个转换规则，如表1所示。七个转换规则可以大致分为三类：混淆数据、混淆函数调用和混淆控制流。 \r 实例化模块：对于以上七个转换规则，作者开发了两个变体用于同步和异步实例化WebAssembly模块。其中异步实例化可以不受浏览器对模块大小的限制并且可以将生成的模块放在单独的文件中。 应用转换：主要包含三个步骤(a)识别能应用转换的AST节点；(b)通过修改可转换片段根节点的子树重写AST；(c)向AST根节点添加代码实例化WebAssembly模块。 ","date":"2022-05-24","objectID":"/public/pr-js/:3:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"实验 作者使用Node.js和Typescript实现Wobfuscator，使用数据集如表2所示。 \r在Cujo、Zozzle、JaSt、JStap四个流行的静态JavaScript检测器上测试了Wobfuscator的有效性，同时与四种开源的JavaScript混淆工具进行了比较。\r\r\r转换的正确性和运行效率\r\r\r","date":"2022-05-24","objectID":"/public/pr-js/:4:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"局限性 Wobfuscator针对基于静态分析的恶意软件检测器可以有效地绕过，但对于基于动态分析的检测器可能不起作用。 该方法只对满足要求的代码片段可以应用转换。 浏览器需要支持WebAssembly。 ","date":"2022-05-24","objectID":"/public/pr-js/:5:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"缓解策略 使用基于动态分析的恶意软件检测：作者提出的方法仍保留了原始的JavaScript恶意行为，动态检测器关注的运行特性不受混淆影响。 基于Wobfuscator提及的转换规则设计检测规则：防御者可以基于对混淆细节的了解，定义相应的规则进行检测。但混淆代码不一定是恶意的，例如保护知识产权，直接将混淆技术分类为恶意可能导致大量误报。 联合分析JavaScript和WebAssembly：联合分析数据和控制流如何在JavaScript和WebAssembly之间流动。 ","date":"2022-05-24","objectID":"/public/pr-js/:6:0","tags":["js","WebAssembly"],"title":"Paper Reading-JS","uri":"/public/pr-js/"},{"categories":["Paper"],"content":"使用系统审计记录进行推荐的网络威胁分析","date":"2022-05-24","objectID":"/public/pr-kg/","tags":["KG","system audit"],"title":"Paper Reading-KG","uri":"/public/pr-kg/"},{"categories":["Paper"],"content":"使用系统审计记录进行推荐的网络威胁分析 原文标题： SHADEWATCHER: Recommendation-guided Cyber Threat Analysis using System Audit Records 原文作者：Zeng J, Wang X, Liu J, et al. 发表会议：2022 IEEE Symposium on Security and Privacy (SP) 原文链接：https://jun-zeng.github.io/file/shadewatcher_paper.pdf ","date":"2022-05-24","objectID":"/public/pr-kg/:0:0","tags":["KG","system audit"],"title":"Paper Reading-KG","uri":"/public/pr-kg/"},{"categories":["Paper"],"content":"简介 现有的系统审计存在局限性：1)大量假告警，2)依赖于专家知识，3)检测信号不精确。论文受网络安全中的威胁检测与信息检索中的推荐之间的结构相似性启发，将系统-实体交互映射为用户-项目交互的推荐概念来识别网络威胁。SHADEWATCHER通过图神经网络挖掘审计记录中的深层信息，实验证明有更高的精度和召回率。 ","date":"2022-05-24","objectID":"/public/pr-kg/:1:0","tags":["KG","system audit"],"title":"Paper Reading-KG","uri":"/public/pr-kg/"},{"categories":["Paper"],"content":"方法 \rSHADEWATCHER架构如图所示，主要包括四个阶段：构建知识图谱(KG)、生成推荐模型、检测网络威胁和调整模型。 KG builder：首先将系统审计记录转换为一个来源图(PG)，节点表示具有一组属性的系统实体，边描述系统实体之间的因果依赖关系和记录出现的时间戳。交互信息抽取模块将数据对象与其交互实体之间的交互抽取为一个二部图(BG)，BG中两个不相交的节点集是数据对象和系统实体，连接两个集合的边反映了相互作用。最后通过实体对齐将PG和BG组合成一个KG。 推荐模型：首先对一阶信息（KG中的一跳连接，例如，/etc/passwd−r1→gtcache）进行建模，通过TransE将系统实体转化为向量表示。然后通过GNN学习来自多跳相邻实体的信息来更新系统实体表示（高阶信息建模）。 威胁检测：将实体划分为正常实体和对抗实体，通过计算两实体的向量表示的内积预测二者间交互的可能性，若概率大于阈值则定义为网络威胁。 模型调整：分析人员可以将识别的假告警作为新负样本重新训练模型。 ","date":"2022-05-24","objectID":"/public/pr-kg/:2:0","tags":["KG","system audit"],"title":"Paper Reading-KG","uri":"/public/pr-kg/"},{"categories":["Paper"],"content":"实验 采用公开数据集DARPA TRACE和之前工作中的模拟攻击数据集，实验表明，SHADEWATCHER检测威胁的精度较高，误报率分别为0.332%和0.137%。 \r","date":"2022-05-24","objectID":"/public/pr-kg/:3:0","tags":["KG","system audit"],"title":"Paper Reading-KG","uri":"/public/pr-kg/"},{"categories":["Paper"],"content":"DSN'21相关论文记录","date":"2021-12-03","objectID":"/public/pl-dsn21/","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":["Paper"],"content":"DSN'21相关论文记录 ","date":"2021-12-03","objectID":"/public/pl-dsn21/:0:0","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":["Paper"],"content":"Statically Detecting JavaScript Obfuscation and Minification Techniques in the Wild 对JavaScript文件执行静态分析，以构建它们的抽象语法树(AST)，使用控制流和数据流对AST进行扩展。定义了两个分类器，基于AST特征检测转换样本以及特定的转换技术。除了恶意样本，我们发现在Node.js库和客户端JavaScript上代码转换越来越常见，例如，90%的Alexa Top 10k网站包含转换后的脚本。这样，代码转换就不是恶意的指示器。最后，我们展示了良性代码转换技术及其频率都不同于流行的恶意代码转换技术。 ","date":"2021-12-03","objectID":"/public/pl-dsn21/:1:0","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":["Paper"],"content":"Hiding in the Particles: When Return-Oriented Programming Meets Program Obfuscation 面向返回的程序设计（ROP） 将程序功能转换为与周围软件堆栈无缝共存的ROP链。我们展示了如何构建能够承受流行的静态和动态去模糊方法的链，评估了设计的健壮性和开销。结果表明，为了实现秘密发现和代码覆盖的目标，进行去模糊攻击需要大量的计算资源。 ","date":"2021-12-03","objectID":"/public/pl-dsn21/:2:0","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":["Paper"],"content":"PDGraph: A Large-Scale Empirical Study on Project Dependency of Security Vulnerabilities 论文提出了第一个关于安全漏洞的项目依赖性的大规模实证研究， ","date":"2021-12-03","objectID":"/public/pl-dsn21/:3:0","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":["Paper"],"content":"PatchDB: A Large-Scale Security Patch Dataset 从github中收集安全补丁，并开发了一种新的最近链接搜索方法来帮助找到最有希望的安全补丁候选。提供了一个合成数据集，它使用一种新的过采样方法，通过丰富原始补丁的控制流变体，在源代码级别合成补丁。 ","date":"2021-12-03","objectID":"/public/pl-dsn21/:4:0","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":["Paper"],"content":"When Program Analysis Meets Bytecode Search: Targeted and Efficient Inter-procedural Analysis of Modern Android Apps in BackDroid 动态字节码搜索，提出一种有针对性的过程间分析范式，它可以跳过不相关的代码，只关注安全敏感的sink APIs流。 ","date":"2021-12-03","objectID":"/public/pl-dsn21/:5:0","tags":["paper list"],"title":"DSN'21 paper list","uri":"/public/pl-dsn21/"},{"categories":null,"content":"About Me","date":"2019-08-02","objectID":"/public/about/","tags":null,"title":"About Me","uri":"/public/about/"}]